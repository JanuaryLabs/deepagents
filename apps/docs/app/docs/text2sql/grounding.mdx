---
title: Grounding
description: How Text2SQL understands your database schema
---


Grounding is the process by which Text2SQL understands your database structure. Before generating SQL, the system introspects your schema and creates a contextual understanding.

## How It Works

```
Database
    │
    ▼
┌─────────────────┐
│   Introspect    │ ← Tables, columns, relationships
└─────────────────┘
    │
    ▼
┌─────────────────┐
│  Brief Agent    │ ← Analyzes and summarizes
└─────────────────┘
    │
    ▼
┌─────────────────┐
│     Cache       │ ← Stores for reuse (keyed by version)
└─────────────────┘
    │
    ▼
  Context for SQL Generation
```

## Schema Introspection

When you create an adapter, it introspects your database to discover:

### Tables
- Table names and schemas
- Column names and data types
- Primary keys

### Relationships
- Foreign key constraints
- Table linkages

### Statistics
- Row counts per table
- Column value ranges (min/max)
- Null percentages
- Index information

### Low Cardinality Detection
Columns with 20 or fewer distinct values are flagged with their actual values:

```typescript
{
  name: 'status',
  type: 'varchar',
  kind: 'LowCardinality',
  values: ['pending', 'active', 'completed', 'cancelled']
}
```

This helps the AI understand valid filter values.

## Size Hints

Tables are classified by row count to help the AI understand query performance:

| Size Hint | Row Count | Implication |
|-----------|-----------|-------------|
| tiny | < 100 | Full table scans are fine |
| small | 100 - 999 | Indexes help but not critical |
| medium | 1,000 - 9,999 | Should use indexes for large results |
| large | 10,000 - 99,999 | Indexes important, consider pagination |
| huge | >= 100,000 | Must use indexes, pagination recommended |

## Caching

Text2SQL automatically caches the generated database context using the `version` parameter:

```typescript
const text2sql = new Text2Sql({
  version: 'v1', // Used for cache key
  adapter: new Sqlite({ execute }),
  history: new InMemoryHistory(),
});
```

### How Caching Works

1. **First query**: Brief agent analyzes the database, result is cached based on `version`
2. **Subsequent queries**: Cached brief is reused
3. **Schema changes**: Bump the `version` to invalidate cache

### Cache Location

Caches are stored as files in the system temp directory:

```
/tmp/text2sql-{md5-hash-of-version}.txt   # Brief cache
/tmp/text2sql-{md5-hash-of-version}.json  # Introspection cache
```

### Cache Invalidation

Bump the version when your schema changes:

```typescript
const text2sql = new Text2Sql({
  version: 'v2', // Bumped version invalidates cache
  adapter: new Sqlite({ execute }),
  history: new InMemoryHistory(),
});
```

## Brief Content

The brief agent generates a 400-600 word summary including:

- **Business context**: What the database represents
- **Table purposes**: What each table stores
- **Row counts**: Data volume understanding
- **Sample data**: Concrete examples of data formats

Example brief excerpt:

```
This database tracks a digital music store.

The Customer table (59 rows) stores customer information including
names like "Luís Gonçalves" and email addresses.

The Invoice table (412 rows) records purchases, with totals
typically ranging from $0.99 to $25.86.

Tracks are priced at $0.99 or $1.99, stored in the Track table
which has 3,503 entries across various genres.
```

## Streaming Brief Status

When using streaming methods, brief cache status is emitted:

```typescript
const stream = await text2sql.single('Show me top customers');

for await (const chunk of stream) {
  if (chunk.type === 'data-brief-agent') {
    console.log('Brief status:', chunk.data.cache);
    // 'hit' - used cached brief
    // 'miss' - generating new brief
    // 'new' - new brief generated and cached
    // 'forced' - cache was forcefully refreshed
  }
}
```

## Custom Introspection

For complex databases, provide custom introspection:

```typescript
new Postgres({
  execute: (sql) => pool.query(sql).then(r => r.rows),
  introspect: async () => ({
    tables: [
      {
        name: 'public.users',
        schema: 'public',
        rawName: 'users',
        columns: [
          { name: 'id', type: 'uuid', isPrimaryKey: true },
          { name: 'email', type: 'varchar', isIndexed: true },
          { name: 'status', type: 'varchar', kind: 'LowCardinality',
            values: ['active', 'inactive', 'banned'] },
        ],
        rowCount: 50000,
        sizeHint: 'large',
      },
    ],
    relationships: [
      {
        table: 'public.orders',
        from: ['user_id'],
        referenced_table: 'public.users',
        to: ['id'],
      },
    ],
  }),
});
```

## Database Schema Prompt Format

The introspection data is formatted into XML for the AI model. The `databaseSchemaPrompt()` function creates:

```xml
<schema_context>
  <dialect_info>
    SQLite-specific information about functions and syntax
  </dialect_info>

  <context>
    Business context summary from brief agent (400-600 words)
  </context>

  <tables>
    - Table: Customer [rows: 59]
      Columns:
        - CustomerId (INTEGER) [PK]
        - FirstName (TEXT)
        - LastName (TEXT)
        - Country (TEXT) [LowCardinality: USA, Canada, Brazil, ...]
        - Email (TEXT)
  </tables>

  <relationships>
    - Invoice (CustomerId) -> Customer (CustomerId) [many-to-one (≈412 vs 59)]
    - InvoiceLine (InvoiceId) -> Invoice (InvoiceId) [many-to-one (≈2,240 vs 412)]
  </relationships>
</schema_context>
```

This structured format helps the AI understand:
- Available tables and columns
- Data types and constraints
- Valid filter values (low cardinality columns)
- Table relationships and cardinality
- Business context for the domain

## Best Practices

1. **Use meaningful versions** - Include schema version for cache invalidation (e.g., `v1`, `v2`)
2. **Monitor cache hits** - Track cache efficiency in production
3. **Update version on schema changes** - Always bump version when schema changes
4. **Consider custom introspection** - For very large databases, provide pre-computed introspection
5. **Provide business context** - The more context in your adapter info, the better the generated queries
