---
title: Grounding
description: How Text2SQL understands your database schema
---


Grounding is the process by which Text2SQL understands your database structure. Before generating SQL, the system introspects your schema and creates a contextual understanding.

## How It Works

```
Database
    │
    ▼
┌─────────────────┐
│   Introspect    │ ← Tables, columns, relationships
└─────────────────┘
    │
    ▼
┌─────────────────┐
│  Brief Agent    │ ← Analyzes and summarizes
└─────────────────┘
    │
    ▼
┌─────────────────┐
│   BriefCache    │ ← Stores for reuse
└─────────────────┘
    │
    ▼
  Context for SQL Generation
```

## Schema Introspection

When you create an adapter, it introspects your database to discover:

### Tables
- Table names and schemas
- Column names and data types
- Primary keys

### Relationships
- Foreign key constraints
- Table linkages

### Statistics
- Row counts per table
- Column value ranges (min/max)
- Null percentages
- Index information

### Low Cardinality Detection
Columns with 20 or fewer distinct values are flagged with their actual values:

```typescript
{
  name: 'status',
  type: 'varchar',
  kind: 'LowCardinality',
  values: ['pending', 'active', 'completed', 'cancelled']
}
```

This helps the AI understand valid filter values.

## Size Hints

Tables are classified by row count to help the AI understand query performance:

| Size Hint | Row Count | Implication |
|-----------|-----------|-------------|
| tiny | < 100 | Full table scans are fine |
| small | 100 - 999 | Indexes help but not critical |
| medium | 1,000 - 9,999 | Should use indexes for large results |
| large | 10,000 - 99,999 | Indexes important, consider pagination |
| huge | >= 100,000 | Must use indexes, pagination recommended |

## BriefCache

The `BriefCache` stores the generated database context to avoid repeated analysis:

```typescript
import { BriefCache } from '@deepagents/text2sql';

// Create a cache with a unique watermark
const cache = new BriefCache('my-database-v1');

const text2sql = new Text2Sql({
  adapter: new Sqlite({ execute }),
  cache: cache,
  history: new InMemoryHistory(),
});
```

### How Caching Works

1. **First query**: Brief agent analyzes the database, result is cached
2. **Subsequent queries**: Cached brief is reused
3. **Schema changes**: Update the watermark to invalidate cache

### Cache Location

Briefs are stored as text files in the system temp directory:

```
/tmp/db-brief-{md5-hash-of-watermark}.txt
```

### Cache Invalidation

Change the watermark when your schema changes:

```typescript
// Version your cache
const cache = new BriefCache('my-database-v2'); // Bump version

// Or use timestamp
const cache = new BriefCache(`my-database-${Date.now()}`);
```

## Brief Content

The brief agent generates a 400-600 word summary including:

- **Business context**: What the database represents
- **Table purposes**: What each table stores
- **Row counts**: Data volume understanding
- **Sample data**: Concrete examples of data formats

Example brief excerpt:

```
This database tracks a digital music store.

The Customer table (59 rows) stores customer information including
names like "Luís Gonçalves" and email addresses.

The Invoice table (412 rows) records purchases, with totals
typically ranging from $0.99 to $25.86.

Tracks are priced at $0.99 or $1.99, stored in the Track table
which has 3,503 entries across various genres.
```

## Streaming Brief Status

When using streaming methods, brief cache status is emitted:

```typescript
const stream = await text2sql.single('Show me top customers');

for await (const chunk of stream) {
  if (chunk.type === 'data-brief-agent') {
    console.log('Brief status:', chunk.data.cache);
    // 'hit' - used cached brief
    // 'miss' - generating new brief
    // 'new' - new brief generated and cached
    // 'forced' - cache was forcefully refreshed
  }
}
```

## Custom Introspection

For complex databases, provide custom introspection:

```typescript
new Postgres({
  execute: (sql) => pool.query(sql).then(r => r.rows),
  introspect: async () => ({
    tables: [
      {
        name: 'public.users',
        schema: 'public',
        rawName: 'users',
        columns: [
          { name: 'id', type: 'uuid', isPrimaryKey: true },
          { name: 'email', type: 'varchar', isIndexed: true },
          { name: 'status', type: 'varchar', kind: 'LowCardinality',
            values: ['active', 'inactive', 'banned'] },
        ],
        rowCount: 50000,
        sizeHint: 'large',
      },
    ],
    relationships: [
      {
        table: 'public.orders',
        from: ['user_id'],
        referenced_table: 'public.users',
        to: ['id'],
      },
    ],
  }),
});
```

## Database Schema Prompt Format

The introspection data is formatted into XML for the AI model. The `databaseSchemaPrompt()` function creates:

```xml
<schema_context>
  <dialect_info>
    SQLite-specific information about functions and syntax
  </dialect_info>

  <context>
    Business context summary from brief agent (400-600 words)
  </context>

  <tables>
    - Table: Customer [rows: 59]
      Columns:
        - CustomerId (INTEGER) [PK]
        - FirstName (TEXT)
        - LastName (TEXT)
        - Country (TEXT) [LowCardinality: USA, Canada, Brazil, ...]
        - Email (TEXT)
  </tables>

  <relationships>
    - Invoice (CustomerId) -> Customer (CustomerId) [many-to-one (≈412 vs 59)]
    - InvoiceLine (InvoiceId) -> Invoice (InvoiceId) [many-to-one (≈2,240 vs 412)]
  </relationships>
</schema_context>
```

This structured format helps the AI understand:
- Available tables and columns
- Data types and constraints
- Valid filter values (low cardinality columns)
- Table relationships and cardinality
- Business context for the domain

## Best Practices

1. **Use meaningful watermarks** - Include version or timestamp for cache invalidation
2. **Monitor cache hits** - Track cache efficiency in production
3. **Update on schema changes** - Always invalidate cache when schema changes
4. **Consider custom introspection** - For very large databases, provide pre-computed introspection
5. **Provide business context** - The more context in your adapter info, the better the generated queries
