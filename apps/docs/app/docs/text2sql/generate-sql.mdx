---
title: Generate SQL
description: Text2SQL provides multiple methods to convert natural language into SQL queries, from pure generation to full execution with streaming.
---

## Methods Overview

| Method     | Returns                    | Use Case                            |
| ---------- | -------------------------- | ----------------------------------- |
| `toSql()`  | SQL string only            | Code generation, previewing queries |
| `single()` | Streaming response         | Interactive execution with progress |
| `chat()`   | Streaming with history     | Multi-turn conversations            |

## Pure SQL Generation with toSql()

Use `toSql()` when you need just the SQL query without execution:

```typescript
const { generate } = await text2sql.toSql(
  'Show me top 10 customers by revenue',
);
const sql = await generate();

console.log(sql);
// SELECT c.CustomerId, c.FirstName, c.LastName, SUM(i.Total) as Revenue
// FROM Customer c
// JOIN Invoice i ON c.CustomerId = i.CustomerId
// GROUP BY c.CustomerId
// ORDER BY Revenue DESC
// LIMIT 10
```

### When to Use toSql()

- Building query previews for users to review
- Generating queries to store/audit
- Integration with existing query execution pipelines
- Testing query generation without database access

## Streaming Execution with single()

Use `single()` for interactive queries with real-time progress:

```typescript
const stream = await text2sql.single('What genres have the most tracks?');

for await (const chunk of stream) {
  switch (chunk.type) {
    case 'text-delta':
      process.stdout.write(chunk.textDelta);
      break;
    case 'tool-call':
      console.log('Executing:', chunk.toolName);
      break;
    case 'tool-result':
      console.log('Result:', chunk.result);
      break;
  }
}
```

### Available Tools in single()

The streaming agent (text2sqlMonolith) has access to these built-in tools:

| Tool              | Purpose                                  |
| ----------------- | ---------------------------------------- |
| `validate_query`  | Check SQL syntax before execution        |
| `get_sample_rows` | Inspect table data to understand formats |
| `db_query`        | Execute the final SQL query (read-only)  |
| `scratchpad`      | Strategic reflection during generation   |

Plus any custom rendering tools you provide.

The `db_query` tool enforces read-only access - only `SELECT` and `WITH` statements are allowed.

### Typical Tool Flow

The agent follows a structured workflow defined in the default teachables:

1. **Translate** the question into SQL patterns (aggregation, segmentation, time range, ranking)
2. **Choose tables** and relations that satisfy those patterns
3. **Inspect samples** with `get_sample_rows` if column formats or codes are unclear
4. **Sketch** join/filter/aggregation order considering table sizes and indexes
5. **Draft** SQL and validate via `validate_query`
6. **Fix** any validation errors
7. **Execute** via `db_query` with reasoning note
8. **Present** results in a business-friendly format

This workflow is encoded in the default teachables as a `workflow()` teachable.

## Step-Back Prompting

Text2SQL uses step-back prompting for complex questions. Instead of jumping straight to SQL, it first considers the underlying patterns needed.

### Example Flow

**Question**: "Who are our top 5 customers by spending?"

**Step-Back Question**: "What are the SQL principles for ranking and aggregation queries?"

**Step-Back Answer**: "Ranking queries require: aggregation functions (SUM) grouped by entity, JOINs to connect related data, ORDER BY the metric, LIMIT for top N."

**Final SQL**:

```sql
SELECT c.FirstName, c.LastName, SUM(i.Total) as total_spent
FROM Customer c
JOIN Invoice i ON c.CustomerId = i.CustomerId
GROUP BY c.CustomerId
ORDER BY total_spent DESC
LIMIT 5
```

### When Step-Back is Skipped

Simple queries skip the step-back process:

- Direct `SELECT * FROM table`
- Simple aggregations with clear targets
- Explicit column lookups

## Output Constraints

All generated queries enforce these constraints:

1. **Read-Only**: Only `SELECT` and `WITH` statements allowed
2. **Row Limit**: Maximum 100 rows in output (use aggregation for larger results)
3. **Validation Required**: Queries are validated before execution

## Custom Rendering Tools

Add visualization capabilities by providing render tools:

```typescript
import { tool } from 'ai';
import z from 'zod';

const text2sql = new Text2Sql({
  version: 'v1',
  adapter: new Sqlite({ execute: (sql) => db.prepare(sql).all() }),
  history: new InMemoryHistory(),
  tools: {
    render_chart: tool({
      description: 'Render a chart visualization',
      inputSchema: z.object({
        type: z.enum(['line', 'bar', 'pie']),
        data: z.array(z.record(z.unknown())),
        xAxis: z.string(),
        yAxis: z.string(),
      }),
      execute: async (params) => {
        // Return chart configuration
        return { chartConfig: params };
      },
    }),
  },
});
```

When rendering tools are available, the agent will:

- Use them for trend/time-series questions
- Apply them when users explicitly request charts
- Prefer line charts for time-based data
- Always include text insights alongside visualizations

## Inspecting the Prompt

To see the full system prompt used for generation:

```typescript
const prompt = await text2sql.inspect();
console.log(prompt);
```

This is useful for debugging and understanding how the AI interprets your schema.

## Error Handling

When queries fail, the adapter provides helpful error messages:

```typescript
try {
  const stream = await text2sql.single('invalid query here');
  // Process stream
} catch (error) {
  // Error includes:
  // - error: Original error message
  // - error_type: Categorized error (MISSING_TABLE, INVALID_COLUMN, etc.)
  // - suggestion: Helpful hint for fixing
  // - sql_attempted: The query that failed
}
```
