---
title: Chat Management
description: Create, update, list, and delete chats with metadata and usage tracking
---

A chat is the top-level container for a conversation. It holds messages, branches, and checkpoints in a graph-based store. Every `ContextEngine` instance is scoped to a single chat.

## Creating a Chat

Chats are created automatically when `ContextEngine` first initializes (on `save()` or `resolve()`). You provide a `chatId` and `userId`:

```typescript
import {
  ContextEngine,
  SqliteContextStore,
  XmlRenderer,
  role,
  user,
  assistant,
} from '@deepagents/context';

const store = new SqliteContextStore('./app.db');

const context = new ContextEngine({
  store,
  chatId: 'chat-001',
  userId: 'user-001',
  metadata: { source: 'web' },
});

context.set(role('You are a helpful assistant.'), user('Hello!'));
await context.save();
```

The engine calls `upsertChat()` internally, so re-using the same `chatId` resumes the existing chat rather than creating a duplicate. The `metadata` option in the constructor is merged into the chat on first initialization.

## Chat ID Strategies

```typescript
const chatId = crypto.randomUUID();

const chatId = `user-${userId}-${Date.now()}`;

const chatId = `chat-${nextId++}`;
```

## Accessing Chat Metadata

The `chat` property returns a `ChatMeta` object after the engine has initialized (after any `save()` or `resolve()` call). Before initialization it returns `null`.

```typescript
const context = new ContextEngine({ store, chatId: 'chat-001', userId: 'user-001' });

context.chat; // null (not yet initialized)

await context.save();

context.chat;
// {
//   id: 'chat-001',
//   userId: 'user-001',
//   createdAt: 1703123456789,
//   updatedAt: 1703123456789,
//   title: undefined,
//   metadata: undefined,
// }

context.chatId; // 'chat-001'
```

### ChatMeta

| Field | Type | Description |
| ----- | ---- | ----------- |
| `id` | `string` | Chat identifier |
| `userId` | `string` | Owner of the chat |
| `createdAt` | `number` | Unix timestamp (ms) |
| `updatedAt` | `number` | Unix timestamp (ms), auto-updated |
| `title` | `string \| undefined` | User-provided title |
| `metadata` | `Record<string, unknown> \| undefined` | Custom key-value data |

## Updating Chat Metadata

Use `updateChat()` to set a title or attach custom metadata:

```typescript
await context.updateChat({
  title: 'Help with TypeScript',
  metadata: {
    tags: ['coding', 'typescript'],
    priority: 'high',
  },
});

console.log(context.chat?.title); // 'Help with TypeScript'
```

Metadata is merged with existing values, not replaced:

```typescript
await context.updateChat({ metadata: { category: 'support' } });
await context.updateChat({ metadata: { resolved: true } });

console.log(context.chat?.metadata);
// { category: 'support', resolved: true }
```

## Listing Chats

Use the store's `listChats()` method directly. Results are sorted by `updatedAt` descending (most recent first).

```typescript
const chats = await store.listChats();

for (const chat of chats) {
  console.log(`${chat.id}: ${chat.title ?? 'Untitled'}`);
  console.log(`  Messages: ${chat.messageCount}, Branches: ${chat.branchCount}`);
  console.log(`  Updated: ${new Date(chat.updatedAt).toLocaleString()}`);
}
```

### Filtering and Pagination

```typescript
const chats = await store.listChats({
  userId: 'user-001',
  limit: 20,
  offset: 0,
});
```

Filter by a top-level metadata field with exact match:

```typescript
const archived = await store.listChats({
  userId: 'user-001',
  metadata: { key: 'archived', value: true },
});
```

### ListChatsOptions

| Option | Type | Description |
| ------ | ---- | ----------- |
| `userId` | `string` | Filter by user |
| `metadata` | `{ key: string; value: string \| number \| boolean }` | Exact match on a top-level metadata field |
| `limit` | `number` | Max results |
| `offset` | `number` | Skip N results (pagination) |

### ChatInfo

Each item returned from `listChats()` is a `ChatInfo`:

| Field | Type | Description |
| ----- | ---- | ----------- |
| `id` | `string` | Chat identifier |
| `userId` | `string` | Owner |
| `title` | `string \| undefined` | Title |
| `metadata` | `Record<string, unknown> \| undefined` | Custom data |
| `messageCount` | `number` | Total messages in the chat |
| `branchCount` | `number` | Total branches |
| `createdAt` | `number` | Unix timestamp (ms) |
| `updatedAt` | `number` | Unix timestamp (ms) |

## Deleting a Chat

Delete a chat and all associated data (messages, branches, checkpoints):

```typescript
const deleted = await store.deleteChat('chat-001');
// true if deleted, false if not found
```

Scope deletion to a specific user to prevent unauthorized deletes:

```typescript
const deleted = await store.deleteChat('chat-001', { userId: 'user-001' });
// false if chat belongs to a different user
```

## Usage Tracking

Track cumulative token usage across the lifetime of a chat with `trackUsage()`. It accumulates `LanguageModelUsage` from the AI SDK into `chat.metadata.usage`:

```typescript
import { generateText } from 'ai';
import { groq } from '@ai-sdk/groq';

const context = new ContextEngine({ store, chatId: 'chat-001', userId: 'user-001' });
context.set(role('You are helpful.'), user('What is TypeScript?'));

const { systemPrompt, messages } = await context.resolve({ renderer: new XmlRenderer() });

const result = await generateText({
  model: groq('gpt-oss-20b'),
  system: systemPrompt,
  messages,
});

context.set(assistant(result.text));
await context.save();

await context.trackUsage(await result.usage);
console.log(context.chat?.metadata?.usage);
// { inputTokens: 45, outputTokens: 120, totalTokens: 165 }
```

Each call to `trackUsage()` adds to the running total. Concurrent calls are safe -- the method reads fresh data from the store before accumulating.

## Multi-User Chat Patterns

### Shared Store, User-Scoped Queries

```typescript
const store = new SqliteContextStore('./app.db');

function getUserChats(userId: string) {
  return store.listChats({ userId, limit: 50 });
}

function createChat(userId: string) {
  return new ContextEngine({
    store,
    chatId: crypto.randomUUID(),
    userId,
  });
}
```

### Safe Deletion

```typescript
async function deleteUserChat(chatId: string, userId: string) {
  const deleted = await store.deleteChat(chatId, { userId });
  if (!deleted) {
    throw new Error('Chat not found or not owned by this user');
  }
}
```

## Complete Example

```typescript
import { generateText } from 'ai';
import { groq } from '@ai-sdk/groq';
import {
  ContextEngine,
  SqliteContextStore,
  XmlRenderer,
  role,
  user,
  assistant,
} from '@deepagents/context';

const store = new SqliteContextStore('./chats.db');

async function sendMessage(chatId: string, userId: string, text: string) {
  const context = new ContextEngine({ store, chatId, userId })
    .set(role('You are a helpful assistant.'));

  context.set(user(text));

  const { systemPrompt, messages } = await context.resolve({
    renderer: new XmlRenderer(),
  });

  const result = await generateText({
    model: groq('gpt-oss-20b'),
    system: systemPrompt,
    messages,
  });

  context.set(assistant(result.text));
  await context.save();

  if (!context.chat?.title) {
    await context.updateChat({ title: text.slice(0, 50) });
  }

  await context.trackUsage(await result.usage);

  return result.text;
}

async function listUserChats(userId: string) {
  return store.listChats({ userId, limit: 50 });
}

async function deleteChat(chatId: string, userId: string) {
  return store.deleteChat(chatId, { userId });
}
```

## Next Steps

- [Context Engine](/docs/context/context-engine) - Full API reference
- [Checkpoints](/docs/context/checkpoints) - Named restore points
- [Branching](/docs/context/branching) - Explore multiple conversation paths
- [Storage](/docs/context/storage) - Store implementations and schema
