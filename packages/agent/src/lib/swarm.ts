import { groq } from '@ai-sdk/groq';
import {
  type CoreMessage,
  type ModelMessage,
  NoSuchToolError,
  Output,
  type PrepareStepFunction,
  type PrepareStepResult,
  type StepResult,
  type ToolCallRepairFunction,
  type ToolSet,
  type UIDataTypes,
  type UIMessage,
  type UIMessagePart,
  type UITools,
  convertToModelMessages,
  createUIMessageStream,
  generateId,
  generateText,
  smoothStream,
  stepCountIs,
  streamText,
  wrapLanguageModel,
} from 'ai';
import chalk from 'chalk';
import dedent from 'dedent';
import { zodToJsonSchema } from 'zod-to-json-schema';

import {
  type Agent,
  type AgentModel,
  type TransferTool,
  isTransferToolResult,
} from './agent.ts';
import { last, messageToUiMessage, user } from './stream_utils.ts';

export type OutputMode = 'full_history' | 'last_message';

export interface ExecuteOptions {
  contextVariables?: Record<string, unknown>;
  systemPrompt?: string;
  abortSignal?: AbortSignal;
  outputMode?: OutputMode;
}

function isToolMessage(message: CoreMessage): boolean {
  return message.role === 'tool';
}

function filterAgentOutput(
  allMessages: CoreMessage[],
  startIndex: number,
  outputMode: OutputMode,
): CoreMessage[] {
  if (outputMode === 'full_history') {
    return allMessages; // Include all messages generated by agent
  }

  if (outputMode === 'last_message') {
    const agentMessages = allMessages.slice(startIndex);
    if (agentMessages.length === 0) return allMessages;

    const lastMsg = agentMessages[agentMessages.length - 1];

    // LangChain logic: if isinstance(messages[-1], ToolMessage): messages = messages[-2:]
    // If last message is a tool message, keep AI message + tool message pair
    if (isToolMessage(lastMsg) && agentMessages.length > 1) {
      const beforeLastMsg = agentMessages[agentMessages.length - 2];
      if (beforeLastMsg.role === 'assistant') {
        return [...allMessages.slice(0, startIndex), beforeLastMsg, lastMsg];
      }
    }

    // LangChain logic: else: messages = messages[-1:]
    // Otherwise, keep just the last message
    return [...allMessages.slice(0, startIndex), lastMsg];
  }

  return allMessages;
}

export function generate<O, C>(
  agent: Agent<O, C>,
  messages: UIMessage[] | string,
  contextVariables: C,
  config?: {
    abortSignal?: AbortSignal;
    providerOptions?: Parameters<typeof streamText>[0]['providerOptions'];
  },
) {
  return generateText({
    abortSignal: config?.abortSignal,
    providerOptions: agent.providerOptions ?? config?.providerOptions,
    model: agent.model,
    system: agent.instructions(contextVariables),
    messages: convertToModelMessages(
      Array.isArray(messages) ? messages : [user(messages)],
    ),
    temperature: agent.temperature,
    stopWhen: stepCountIs(25),
    tools: agent.toToolset(),
    activeTools: agent.toolsNames,
    experimental_context: contextVariables,
    toolChoice: agent.toolChoice,
    experimental_output: agent.output
      ? Output.object({ schema: agent.output })
      : undefined,
    // onStepFinish: (step) => tagAgents(step, agent.handoff.name),
    onStepFinish: (step) => {
      const toolCall = step.toolCalls.at(-1);
      if (toolCall) {
        console.log(
          `Debug: ${chalk.yellow('ToolCalled')}: ${toolCall.toolName}(${JSON.stringify(toolCall.input)})`,
        );
      }
    },
    prepareStep: prepareStep(agent, agent.model, contextVariables),
    // onFinish: (result) => {
    //   (contextVariables as any).content = result.content;
    // },
  });
}

export function execute<O, C>(
  agent: Agent<O, C>,
  messages: UIMessage[] | string,
  contextVariables: C,
  config?: {
    abortSignal?: AbortSignal;
    providerOptions?: Parameters<typeof streamText>[0]['providerOptions'];
  },
) {
  const runId = generateId();
  return streamText({
    abortSignal: config?.abortSignal,
    providerOptions: config?.providerOptions,
    model: agent.model,
    system: agent.instructions(contextVariables),
    messages: convertToModelMessages(
      Array.isArray(messages) ? messages : [user(messages)],
    ),
    temperature: agent.temperature,
    stopWhen: stepCountIs(25),
    experimental_transform: smoothStream(),
    tools: agent.toToolset(),
    activeTools: agent.toolsNames,
    experimental_context: contextVariables,
    toolChoice: agent.toolChoice,
    experimental_repairToolCall: repairToolCall,
    onError: (error) => {
      console.error(
        chalk.red(
          `Error during agent (${agent.internalName})(${runId}) execution: `,
        ),
        error instanceof Error ? error.message : error,
      );
      console.dir(error, { depth: null });
    },
    experimental_output: agent.output
      ? Output.object({ schema: agent.output })
      : undefined,
    // onStepFinish: (step) => tagAgents(step, agent.handoff.name),
    onStepFinish: (step) => {
      const toolCall = step.toolCalls.at(-1);
      if (toolCall) {
        console.log(
          `Debug: (${runId}) ${chalk.bold.yellow('ToolCalled')}: ${toolCall.toolName}(${JSON.stringify(toolCall.input)})`,
        );
      }
    },
    prepareStep: prepareStep(agent, agent.model, contextVariables),
    // onFinish: (result) => {
    //   (contextVariables as any).content = result.content;
    // },
  });
}

export const stream = execute;

export const prepareStep = <C>(
  agent: Agent<unknown, C>,
  model: AgentModel,
  contextVariables: C,
): PrepareStepFunction<NoInfer<ToolSet>> => {
  return async ({ steps, messages }) => {
    const step = steps.at(-1);
    const agentName = (contextVariables as any).currentActiveAgent;
    if (!step) {
      return await prepareAgent(model, agent, messages, contextVariables);
    }
    if (!agentName) {
      return await prepareAgent(model, agent, messages, contextVariables);
    }

    const nextAgent = findAgent(agent, agentName);
    if (!nextAgent) {
      console.error(`Debug: ${chalk.red('NotFound')}: Agent ${agentName}`);
      console.dir(
        {
          steps: steps.map(({ request, response, ...etc }) => etc),
          messages,
        },
        { depth: null },
      );
      return void 0;
    }
    return await prepareAgent(model, nextAgent, messages, contextVariables);
  };
};

export function swarm<C>(
  agent: Agent<unknown, C>,
  messages: UIMessage[] | string,
  contextVariables: C,
  abortSignal?: AbortSignal,
) {
  const originalMessages = Array.isArray(messages)
    ? messages
    : [messageToUiMessage(messages)];
  return createUIMessageStream({
    originalMessages,
    generateId: generateId,
    async execute({ writer }) {
      const stream = execute(agent, originalMessages, contextVariables, {
        abortSignal,
      });
      const parts: UIMessagePart<UIDataTypes, UITools>[] = [];

      writer.merge(
        stream.toUIMessageStream({
          sendFinish: false,
          sendStart: true,
          onFinish: (event) => {
            parts.push(...event.responseMessage.parts);
          },
        }),
      );
      await stream.consumeStream({ onError: console.error });
      await last(stream.fullStream);

      if (!agent.prepareEnd) return;

      while (true) {
        const state = contextVariables as any;
        if (state.currentActiveAgent === undefined) {
          console.warn(
            `swarm: active agent was never set, so no prepareEnd call will be made`,
          );
          return;
        }
        if (state.currentActiveAgent === agent.internalName) {
          console.warn(
            `swarm: active agent is the root agent, so no prepareEnd call will be made`,
          );
          return;
        }
        const responseMessage = { id: '', parts, role: 'assistant' } as const;

        const stream = agent.prepareEnd({
          responseMessage,
          messages: [...originalMessages, responseMessage],
          contextVariables,
          abortSignal,
        });
        if (!stream) break;

        writer.merge(
          stream.toUIMessageStream({
            sendFinish: false,
            sendStart: false,
            onFinish: (event) => {
              parts.push(...event.responseMessage.parts);
            },
          }),
        );
        await stream.consumeStream({ onError: console.error });
        await last(stream.fullStream);
      }

      writer.write({ type: 'finish' });
    },
  });
}

export async function prepareAgent<C>(
  defaultModel: AgentModel,
  agent: Agent<unknown, C>,
  messages: ModelMessage[],
  contextVariables?: C,
): Promise<PrepareStepResult<NoInfer<ToolSet>>> {
  agent.debug();
  await agent.prepareHandoff?.(messages);

  let stepModel = agent.model ?? defaultModel;
  if (agent.output) {
    const json_schema = zodToJsonSchema(agent.output, {
      $refStrategy: 'root',
    });
    stepModel = wrapLanguageModel({
      model: stepModel,
      middleware: {
        transformParams: async ({ params }) => ({
          ...params,
          response_format: {
            type: 'json_schema',
            json_schema,
            name: `${agent.handoff.name}_output`,
          },
        }),
      },
    });
  }
  return {
    system: agent.instructions(contextVariables),
    activeTools: agent.toolsNames,
    model: stepModel,
    messages,
    // messages: removeTransferCalls(messages),
    toolChoice: agent.toolChoice,
  } as const;
}

function getLastAgentFromSteps(
  steps: StepResult<NoInfer<ToolSet>>[],
): string | undefined {
  for (let i = steps.length - 1; i >= 0; i--) {
    const step = steps[i];
    for (const it of step.dynamicToolResults) {
      if (isTransferToolResult(it)) {
        return it.output.currentActiveAgent;
      }
    }
  }
  return void 0;
}

function findAgent<C>(agent: Agent<unknown, C>, agentName: string) {
  // FIXME: first argument agent not always the first passed agent.
  return [...agent.toHandoffs(), agent].find(
    (it) => it.handoff.name === agentName,
  );
}

function getActiveAgentName(messages: ModelMessage[]): string | undefined {
  for (let i = messages.length - 1; i >= 0; i--) {
    const message = messages[i];

    if (message.role === 'tool') {
      for (const block of message.content) {
        if (
          block.type === 'tool-result' &&
          block.toolName.startsWith('transfer_to_') &&
          block.output.type === 'json' &&
          isTransferToolResult({ output: block.output.value })
        ) {
          return (block.output.value as TransferTool['output'])
            .currentActiveAgent;
        }
      }
    }
  }
  return undefined;
}

function tagAgents(
  step: StepResult<NoInfer<ToolSet>>,
  defaultAgentName: string,
) {
  const { request, response, ...stepResult } = step;
  // let transferToolResultIdx = -1;
  const messages = response.messages;
  let agentName: string | undefined;

  // look for the last agent from the step
  for (let i = stepResult.content.length - 1; i >= 0; i--) {
    const block = stepResult.content[i];
    if (
      block.type === 'tool-result' &&
      block.dynamic &&
      block.toolName.startsWith('transfer_to_') &&
      isTransferToolResult(block)
    ) {
      // If we found a dynamic tool result, we can use it
      agentName = block.output.lastActiveAgent;
      // transferToolResultIdx = i;
      break;
    }
  }

  // if no agent in the step result, look for for it in the messages
  // todo: can we just use this instead of looking into the step result?
  if (!agentName) {
    for (const message of messages.slice(0).reverse()) {
      if (
        message.role === 'tool' &&
        message.content[0].type === 'tool-result' &&
        message.content[0].toolName.startsWith('transfer_to_') &&
        isTransferToolResult({
          output: message.content[0].output.value,
        })
      ) {
        agentName = (message.content[0].output.value as TransferTool['output'])
          .currentActiveAgent;
        break;
      }
    }
  }

  if (!agentName) {
    agentName = defaultAgentName;
  }

  for (const block of stepResult.content) {
    if (block.type === 'text' && !block.text.startsWith('<name>')) {
      block.text = `<name>${agentName}</name><content>${dedent(block.text)}</content>`;
    }
  }
  // console.log(
  //   `Debug: ${chalk.red('NoOp')}: No transfer tool result found.`,
  // );
  // console.dir({ stepResult, messages }, { depth: null });
}

function removeTransferCalls(messages: ModelMessage[]): ModelMessage[] {
  for (const message of messages) {
    if (message.role === 'assistant') {
      if (typeof message.content === 'string') continue;

      for (let i = message.content.length - 1; i >= 0; i--) {
        const block = message.content[i];
        if (typeof block === 'string') continue;

        if (
          (block.type === 'tool-call' || block.type === 'tool-result') &&
          block.toolName.startsWith('transfer_to_')
        ) {
          message.content.splice(i, 1);
        }
      }
    }
  }
  return messages;
}

const repairToolCall: ToolCallRepairFunction<ToolSet> = async ({
  toolCall,
  tools,
  inputSchema,
  error,
}) => {
  if (NoSuchToolError.isInstance(error)) {
    return null; // do not attempt to fix invalid tool names
  }

  console.log(
    `Debug: ${chalk.yellow('RepairingToolCall')}: ${toolCall.toolName}`,
  );

  const tool = tools[toolCall.toolName as keyof typeof tools];

  const { experimental_output } = await generateText({
    model: groq('openai/gpt-oss-20b'),
    experimental_output: Output.object({ schema: tool.inputSchema }),
    prompt: [
      `The model tried to call the tool "${toolCall.toolName}"` +
        ` with the following inputs:`,
      JSON.stringify(toolCall.input),
      `The tool accepts the following schema:`,
      JSON.stringify(inputSchema(toolCall)),
      'Please fix the inputs.',
    ].join('\n'),
  });

  return { ...toolCall, input: JSON.stringify(experimental_output) };
};
