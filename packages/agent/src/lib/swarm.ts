import { groq } from '@ai-sdk/groq';
import {
  type CoreMessage,
  type ModelMessage,
  NoSuchToolError,
  Output,
  type PrepareStepFunction,
  type PrepareStepResult,
  type StepResult,
  type ToolCallRepairFunction,
  type ToolSet,
  type UIDataTypes,
  type UIMessage,
  type UIMessagePart,
  type UIMessageStreamWriter,
  type UITools,
  convertToModelMessages,
  createUIMessageStream,
  generateId,
  generateText,
  smoothStream,
  stepCountIs,
  streamText,
  wrapLanguageModel,
} from 'ai';
import chalk from 'chalk';
import dedent from 'dedent';
import { zodToJsonSchema } from 'zod-to-json-schema';

import {
  type Agent,
  type AgentModel,
  type TransferTool,
  isTransferToolResult,
} from './agent.ts';
import { last, messageToUiMessage, user } from './stream_utils.ts';

export type OutputMode = 'full_history' | 'last_message';

export interface ExecuteOptions {
  contextVariables?: Record<string, unknown>;
  systemPrompt?: string;
  abortSignal?: AbortSignal;
  outputMode?: OutputMode;
}

function isToolMessage(message: CoreMessage): boolean {
  return message.role === 'tool';
}

function filterAgentOutput(
  allMessages: CoreMessage[],
  startIndex: number,
  outputMode: OutputMode,
): CoreMessage[] {
  if (outputMode === 'full_history') {
    return allMessages; // Include all messages generated by agent
  }

  if (outputMode === 'last_message') {
    const agentMessages = allMessages.slice(startIndex);
    if (agentMessages.length === 0) return allMessages;

    const lastMsg = agentMessages[agentMessages.length - 1];

    // LangChain logic: if isinstance(messages[-1], ToolMessage): messages = messages[-2:]
    // If last message is a tool message, keep AI message + tool message pair
    if (isToolMessage(lastMsg) && agentMessages.length > 1) {
      const beforeLastMsg = agentMessages[agentMessages.length - 2];
      if (beforeLastMsg.role === 'assistant') {
        return [...allMessages.slice(0, startIndex), beforeLastMsg, lastMsg];
      }
    }

    // LangChain logic: else: messages = messages[-1:]
    // Otherwise, keep just the last message
    return [...allMessages.slice(0, startIndex), lastMsg];
  }

  return allMessages;
}

export function generate<O, CIn, COut = CIn>(
  agent: Agent<O, CIn, COut>,
  messages: UIMessage[] | string,
  contextVariables: CIn,
  config?: {
    abortSignal?: AbortSignal;
    providerOptions?: Parameters<typeof streamText>[0]['providerOptions'];
  },
) {
  const result = generateText({
    abortSignal: config?.abortSignal,
    providerOptions: agent.providerOptions ?? config?.providerOptions,
    model: agent.model,
    system: agent.instructions(contextVariables),
    messages: convertToModelMessages(
      Array.isArray(messages) ? messages : [user(messages)],
    ),
    temperature: agent.temperature,
    stopWhen: stepCountIs(25),
    tools: agent.toToolset(),
    activeTools: agent.toolsNames,
    experimental_context: contextVariables,
    toolChoice: agent.toolChoice,
    experimental_output: agent.output
      ? Output.object({ schema: agent.output })
      : undefined,
    // onStepFinish: (step) => tagAgents(step, agent.handoff.name),
    onStepFinish: (step) => {
      const toolCall = step.toolCalls.at(-1);
      if (toolCall) {
        console.log(
          `Debug: ${chalk.yellow('ToolCalled')}: ${toolCall.toolName}(${JSON.stringify(toolCall.input)})`,
        );
      }
    },
    prepareStep: prepareStep(agent, agent.model, contextVariables),
    // onFinish: (result) => {
    //   (contextVariables as any).content = result.content;
    // },
  });
  return Object.assign(result, { state: contextVariables as unknown as COut });
}

export function execute<O, CIn, COut = CIn>(
  agent: Agent<O, CIn, COut>,
  messages: UIMessage[] | string,
  contextVariables: CIn,
  config?: {
    abortSignal?: AbortSignal;
    providerOptions?: Parameters<typeof streamText>[0]['providerOptions'];
  },
) {
  const runId = generateId();
  const stream = streamText({
    abortSignal: config?.abortSignal,
    providerOptions: config?.providerOptions,
    model: agent.model,
    system: agent.instructions(contextVariables),
    messages: convertToModelMessages(
      Array.isArray(messages) ? messages : [user(messages)],
    ),
    temperature: agent.temperature,
    stopWhen: stepCountIs(25),
    experimental_transform: smoothStream(),
    tools: agent.toToolset(),
    activeTools: agent.toolsNames,
    experimental_context: contextVariables,
    toolChoice: agent.toolChoice,
    experimental_repairToolCall: repairToolCall,
    onError: (error) => {
      console.error(
        chalk.red(
          `Error during agent (${agent.internalName})(${runId}) execution: `,
        ),
        error instanceof Error ? error.message : error,
      );
      console.dir(error, { depth: null });
    },
    experimental_output: agent.output
      ? Output.object({ schema: agent.output })
      : undefined,
    // onStepFinish: (step) => tagAgents(step, agent.handoff.name),
    onStepFinish: (step) => {
      const toolCall = step.toolCalls.at(-1);
      if (toolCall) {
        console.log(
          `Debug: (${runId}) ${chalk.bold.yellow('ToolCalled')}: ${toolCall.toolName}(${JSON.stringify(toolCall.input)})`,
        );
      }
    },
    prepareStep: prepareStep(agent, agent.model, contextVariables),
    // onFinish: (result) => {
    //   (contextVariables as any).content = result.content;
    // },
  });
  return Object.assign(stream, { state: contextVariables as unknown as COut });
}

export const stream = execute;

export interface ExecuteWithRetryConfig {
  maxRetries?: number;
  abortSignal?: AbortSignal;
  providerOptions?: Parameters<typeof streamText>[0]['providerOptions'];
  /** Called when an error is caught and will be retried */
  onRetry?: (error: unknown, attempt: number) => void;
}

/**
 * Executes an agent with automatic error recovery.
 * When streamText encounters an error, this function catches it,
 * injects the error context into messages, and retries.
 * Returns a UIMessageStream so the UI continues to function.
 */
export function executeWithRetry<O, CIn, COut = CIn>(
  agent: Agent<O, CIn, COut>,
  messages: UIMessage[] | string,
  contextVariables: CIn,
  config?: ExecuteWithRetryConfig,
) {
  const maxRetries = config?.maxRetries ?? 3;
  const originalMessages = Array.isArray(messages)
    ? messages
    : [messageToUiMessage(messages)];

  return createUIMessageStream({
    originalMessages,
    generateId,
    onError: (error) => {
      console.error('UIMessageStream error:', error);
      return error instanceof Error ? error.message : String(error);
    },
    execute: async ({ writer }) => {
      let attempt = 0;
      let currentMessages = [...originalMessages];
      let lastError: string | null = null;

      while (attempt < maxRetries) {
        attempt++;
        const runId = generateId();

        // If we have a previous error, inject it as context for the LLM
        if (lastError) {
          const errorMessage: UIMessage = {
            id: generateId(),
            role: 'user',
            parts: [
              {
                type: 'text',
                text: `The previous attempt encountered an error: ${lastError}. Please try again or use a different approach.`,
              },
            ],
          };
          currentMessages = [...currentMessages, errorMessage];
          // Write retry notification to stream for UI feedback
          writer.write({ type: 'text-start', id: generateId() });
          writer.write({
            type: 'text-delta',
            id: generateId(),
            delta: `\n[Retrying after error: ${lastError}]\n`,
          });
          writer.write({ type: 'text-end', id: generateId() });
        }

        try {
          const streamResult = await executeStreamWithErrorDetection(
            agent,
            currentMessages,
            contextVariables,
            writer,
            runId,
            config,
          );

          if (streamResult.success) {
            // Stream completed successfully
            return;
          }

          // Stream had an error, prepare for retry
          lastError = streamResult.error;
          config?.onRetry?.(streamResult.error, attempt);

          console.warn(
            chalk.yellow(
              `[executeWithRetry] Attempt ${attempt}/${maxRetries} failed: ${lastError}`,
            ),
          );
        } catch (error) {
          // Unexpected error during stream setup
          lastError =
            error instanceof Error ? error.message : JSON.stringify(error);
          config?.onRetry?.(error, attempt);

          console.error(
            chalk.red(
              `[executeWithRetry] Attempt ${attempt}/${maxRetries} threw: ${lastError}`,
            ),
          );
        }
      }

      // All retries exhausted
      writer.write({
        type: 'error',
        errorText: `Failed after ${maxRetries} attempts. Last error: ${lastError}`,
      });
    },
  });
}

async function executeStreamWithErrorDetection<O, CIn, COut>(
  agent: Agent<O, CIn, COut>,
  messages: UIMessage[],
  contextVariables: CIn,
  writer: UIMessageStreamWriter,
  runId: string,
  config?: ExecuteWithRetryConfig,
): Promise<{ success: true } | { success: false; error: string }> {
  let detectedError: string | null = null;

  const stream = streamText({
    abortSignal: config?.abortSignal,
    providerOptions: config?.providerOptions,
    model: agent.model,
    system: agent.instructions(contextVariables),
    messages: convertToModelMessages(messages),
    temperature: agent.temperature,
    stopWhen: stepCountIs(25),
    experimental_transform: smoothStream(),
    tools: agent.toToolset(),
    activeTools: agent.toolsNames,
    experimental_context: contextVariables,
    toolChoice: agent.toolChoice,
    experimental_repairToolCall: repairToolCall,
    onError: (error) => {
      const errorMsg = error instanceof Error ? error.message : String(error);
      console.error(
        chalk.red(`[executeWithRetry] (${runId}) Stream error: ${errorMsg}`),
      );
      detectedError = errorMsg;
    },
    experimental_output: agent.output
      ? Output.object({ schema: agent.output })
      : undefined,
    onStepFinish: (step) => {
      // Check for tool errors in step content (tool-error parts appear in content array)
      for (const content of step.content) {
        if (content.type === 'tool-result' && 'isError' in content && content.isError) {
          console.warn(
            chalk.yellow(`[executeWithRetry] (${runId}) Tool error detected in: ${content.toolName}`),
          );
        }
      }

      const toolCall = step.toolCalls.at(-1);
      if (toolCall) {
        console.log(
          `Debug: (${runId}) ${chalk.bold.yellow('ToolCalled')}: ${toolCall.toolName}(${JSON.stringify(toolCall.input)})`,
        );
      }
    },
    prepareStep: prepareStep(agent, agent.model, contextVariables),
  });

  // Merge the stream to the writer while monitoring for errors
  writer.merge(
    stream.toUIMessageStream({
      generateMessageId: generateId,
      originalMessages: messages,
    }),
  );

  // Consume the stream and check for errors in fullStream
  try {
    for await (const part of stream.fullStream) {
      if (part.type === 'error') {
        detectedError = part.error instanceof Error
          ? part.error.message
          : String(part.error);
        break;
      }
    }
  } catch (consumeError) {
    detectedError =
      consumeError instanceof Error
        ? consumeError.message
        : String(consumeError);
  }

  if (detectedError) {
    return { success: false, error: detectedError };
  }

  return { success: true };
}

export const prepareStep = <CIn>(
  agent: Agent<unknown, CIn, any>,
  model: AgentModel,
  contextVariables: CIn,
): PrepareStepFunction<NoInfer<ToolSet>> => {
  return async ({ steps, messages }) => {
    const step = steps.at(-1);
    const agentName = (contextVariables as any).currentActiveAgent;
    if (!step) {
      return await prepareAgent(model, agent, messages, contextVariables);
    }
    if (!agentName) {
      return await prepareAgent(model, agent, messages, contextVariables);
    }

    const nextAgent = findAgent(agent, agentName);
    if (!nextAgent) {
      console.error(`Debug: ${chalk.red('NotFound')}: Agent ${agentName}`);
      console.dir(
        {
          steps: steps.map(({ request, response, ...etc }) => etc),
          messages,
        },
        { depth: null },
      );
      return void 0;
    }
    return await prepareAgent(model, nextAgent, messages, contextVariables);
  };
};

export function swarm<CIn>(
  agent: Agent<unknown, CIn, any>,
  messages: UIMessage[] | string,
  contextVariables: CIn,
  abortSignal?: AbortSignal,
) {
  const originalMessages = Array.isArray(messages)
    ? messages
    : [messageToUiMessage(messages)];
  return createUIMessageStream({
    originalMessages,
    generateId: generateId,
    async execute({ writer }) {
      const stream = execute(agent, originalMessages, contextVariables, {
        abortSignal,
      });
      const parts: UIMessagePart<UIDataTypes, UITools>[] = [];

      writer.merge(
        stream.toUIMessageStream({
          sendFinish: false,
          sendStart: true,
          onFinish: (event) => {
            parts.push(...event.responseMessage.parts);
          },
        }),
      );
      await stream.consumeStream({ onError: console.error });
      await last(stream.fullStream);

      if (!agent.prepareEnd) return;

      while (true) {
        const state = contextVariables as any;
        if (state.currentActiveAgent === undefined) {
          console.warn(
            `swarm: active agent was never set, so no prepareEnd call will be made`,
          );
          return;
        }
        if (state.currentActiveAgent === agent.internalName) {
          console.warn(
            `swarm: active agent is the root agent, so no prepareEnd call will be made`,
          );
          return;
        }
        const responseMessage = { id: '', parts, role: 'assistant' } as const;

        const stream = agent.prepareEnd({
          responseMessage,
          messages: [...originalMessages, responseMessage],
          contextVariables,
          abortSignal,
        });
        if (!stream) break;

        writer.merge(
          stream.toUIMessageStream({
            sendFinish: false,
            sendStart: false,
            onFinish: (event) => {
              parts.push(...event.responseMessage.parts);
            },
          }),
        );
        await stream.consumeStream({ onError: console.error });
        await last(stream.fullStream);
      }

      writer.write({ type: 'finish' });
    },
  });
}

export async function prepareAgent<CIn>(
  defaultModel: AgentModel,
  agent: Agent<unknown, CIn, any>,
  messages: ModelMessage[],
  contextVariables?: CIn,
): Promise<PrepareStepResult<NoInfer<ToolSet>>> {
  agent.debug();
  await agent.prepareHandoff?.(messages);

  let stepModel = agent.model ?? defaultModel;
  if (agent.output) {
    const json_schema = zodToJsonSchema(agent.output, {
      $refStrategy: 'root',
    });
    stepModel = wrapLanguageModel({
      model: stepModel,
      middleware: {
        transformParams: async ({ params }) => ({
          ...params,
          response_format: {
            type: 'json_schema',
            json_schema,
            name: `${agent.handoff.name}_output`,
          },
        }),
      },
    });
  }
  return {
    system: agent.instructions(contextVariables),
    activeTools: agent.toolsNames,
    model: stepModel,
    messages,
    // messages: removeTransferCalls(messages),
    toolChoice: agent.toolChoice,
  } as const;
}

function getLastAgentFromSteps(
  steps: StepResult<NoInfer<ToolSet>>[],
): string | undefined {
  for (let i = steps.length - 1; i >= 0; i--) {
    const step = steps[i];
    for (const it of step.dynamicToolResults) {
      if (isTransferToolResult(it)) {
        return it.output.currentActiveAgent;
      }
    }
  }
  return void 0;
}

function findAgent<CIn>(agent: Agent<unknown, CIn, any>, agentName: string) {
  // FIXME: first argument agent not always the first passed agent.
  return [...agent.toHandoffs(), agent].find(
    (it) => it.handoff.name === agentName,
  );
}

function getActiveAgentName(messages: ModelMessage[]): string | undefined {
  for (let i = messages.length - 1; i >= 0; i--) {
    const message = messages[i];

    if (message.role === 'tool') {
      for (const block of message.content) {
        if (
          block.type === 'tool-result' &&
          block.toolName.startsWith('transfer_to_') &&
          block.output.type === 'json' &&
          isTransferToolResult({ output: block.output.value })
        ) {
          return (block.output.value as TransferTool['output'])
            .currentActiveAgent;
        }
      }
    }
  }
  return undefined;
}

function tagAgents(
  step: StepResult<NoInfer<ToolSet>>,
  defaultAgentName: string,
) {
  const { request, response, ...stepResult } = step;
  // let transferToolResultIdx = -1;
  const messages = response.messages;
  let agentName: string | undefined;

  // look for the last agent from the step
  for (let i = stepResult.content.length - 1; i >= 0; i--) {
    const block = stepResult.content[i];
    if (
      block.type === 'tool-result' &&
      block.dynamic &&
      block.toolName.startsWith('transfer_to_') &&
      isTransferToolResult(block)
    ) {
      // If we found a dynamic tool result, we can use it
      agentName = block.output.lastActiveAgent;
      // transferToolResultIdx = i;
      break;
    }
  }

  // if no agent in the step result, look for for it in the messages
  // todo: can we just use this instead of looking into the step result?
  if (!agentName) {
    for (const message of messages.slice(0).reverse()) {
      if (
        message.role === 'tool' &&
        message.content[0].type === 'tool-result' &&
        message.content[0].toolName.startsWith('transfer_to_') &&
        isTransferToolResult({
          output: message.content[0].output.value,
        })
      ) {
        agentName = (message.content[0].output.value as TransferTool['output'])
          .currentActiveAgent;
        break;
      }
    }
  }

  if (!agentName) {
    agentName = defaultAgentName;
  }

  for (const block of stepResult.content) {
    if (block.type === 'text' && !block.text.startsWith('<name>')) {
      block.text = `<name>${agentName}</name><content>${dedent(block.text)}</content>`;
    }
  }
  // console.log(
  //   `Debug: ${chalk.red('NoOp')}: No transfer tool result found.`,
  // );
  // console.dir({ stepResult, messages }, { depth: null });
}

function removeTransferCalls(messages: ModelMessage[]): ModelMessage[] {
  for (const message of messages) {
    if (message.role === 'assistant') {
      if (typeof message.content === 'string') continue;

      for (let i = message.content.length - 1; i >= 0; i--) {
        const block = message.content[i];
        if (typeof block === 'string') continue;

        if (
          (block.type === 'tool-call' || block.type === 'tool-result') &&
          block.toolName.startsWith('transfer_to_')
        ) {
          message.content.splice(i, 1);
        }
      }
    }
  }
  return messages;
}

const repairToolCall: ToolCallRepairFunction<ToolSet> = async ({
  toolCall,
  tools,
  inputSchema,
  error,
}) => {
  if (NoSuchToolError.isInstance(error)) {
    return null; // do not attempt to fix invalid tool names
  }

  console.log(
    `Debug: ${chalk.yellow('RepairingToolCall')}: ${toolCall.toolName}`,
  );

  const tool = tools[toolCall.toolName as keyof typeof tools];

  const { experimental_output } = await generateText({
    model: groq('openai/gpt-oss-20b'),
    experimental_output: Output.object({ schema: tool.inputSchema }),
    prompt: [
      `The model tried to call the tool "${toolCall.toolName}"` +
        ` with the following inputs:`,
      JSON.stringify(toolCall.input),
      `The tool accepts the following schema:`,
      JSON.stringify(inputSchema(toolCall)),
      'Please fix the inputs.',
    ].join('\n'),
  });

  return { ...toolCall, input: JSON.stringify(experimental_output) };
};
