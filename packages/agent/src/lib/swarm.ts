import {
  type CoreMessage,
  type ModelMessage,
  Output,
  type PrepareStepFunction,
  type PrepareStepResult,
  type StepResult,
  type Tool,
  type UIDataTypes,
  type UIMessage,
  type UIMessagePart,
  type UITools,
  convertToModelMessages,
  createUIMessageStream,
  generateId,
  smoothStream,
  stepCountIs,
  streamText,
  wrapLanguageModel,
} from 'ai';
import chalk from 'chalk';
import dedent from 'dedent';
import { zodToJsonSchema } from 'zod-to-json-schema';

import {
  type Agent,
  type AgentModel,
  type TransferTool,
  isTransferToolResult,
} from './agent.ts';
import { lmstudio } from './models.ts';
import { last, messageToUiMessage } from './stream_utils.ts';

export type OutputMode = 'full_history' | 'last_message';

export interface ExecuteOptions {
  contextVariables?: Record<string, unknown>;
  systemPrompt?: string;
  abortSignal?: AbortSignal;
  outputMode?: OutputMode;
}

function isToolMessage(message: CoreMessage): boolean {
  return message.role === 'tool';
}

function filterAgentOutput(
  allMessages: CoreMessage[],
  startIndex: number,
  outputMode: OutputMode,
): CoreMessage[] {
  if (outputMode === 'full_history') {
    return allMessages; // Include all messages generated by agent
  }

  if (outputMode === 'last_message') {
    const agentMessages = allMessages.slice(startIndex);
    if (agentMessages.length === 0) return allMessages;

    const lastMsg = agentMessages[agentMessages.length - 1];

    // LangChain logic: if isinstance(messages[-1], ToolMessage): messages = messages[-2:]
    // If last message is a tool message, keep AI message + tool message pair
    if (isToolMessage(lastMsg) && agentMessages.length > 1) {
      const beforeLastMsg = agentMessages[agentMessages.length - 2];
      if (beforeLastMsg.role === 'assistant') {
        return [...allMessages.slice(0, startIndex), beforeLastMsg, lastMsg];
      }
    }

    // LangChain logic: else: messages = messages[-1:]
    // Otherwise, keep just the last message
    return [...allMessages.slice(0, startIndex), lastMsg];
  }

  return allMessages;
}

export function execute<C>(
  agent: Agent<C>,
  messages: UIMessage[] | string,
  contextVariables: C,
  prompt?: string,
  config?: {
    abortSignal?: AbortSignal;
    providerOptions?: Parameters<typeof streamText>[0]['providerOptions'];
  },
) {
  const model = agent.model ?? lmstudio('qwen/qwen3-4b-2507');

  // Ensure messages are properly converted to UIMessage array
  const uiMessages = Array.isArray(messages)
    ? messages
    : [messageToUiMessage(messages)];

  return streamText({
    abortSignal: config?.abortSignal,
    providerOptions: config?.providerOptions,
    model: model,
    system: `${prompt}\n${agent.instructions(contextVariables)}`,
    messages: convertToModelMessages(uiMessages),
    temperature: agent.temperature ?? 0,
    stopWhen: stepCountIs(25),
    experimental_transform: smoothStream(),
    tools: agent.toToolset(),
    activeTools: agent.toolsNames,
    experimental_context: contextVariables,
    toolChoice: agent.toolChoice,
    onError: (error) => {
      console.error(
        chalk.red(`Error during agent (${agent.internalName}) execution: `),
        error instanceof Error ? error.message : error,
      );
      console.dir(error, { depth: null });
    },
    experimental_output: agent.output
      ? Output.object({ schema: agent.output })
      : undefined,
    // onStepFinish: (step) => tagAgents(step, agent.handoff.name),
    onStepFinish: (step) => {
      const toolCall = step.toolCalls.at(-1);
      if (toolCall) {
        console.log(
          `Debug: ${chalk.yellow('ToolCalled')}: ${toolCall.toolName}(${JSON.stringify(toolCall.input)})`,
        );
      }
    },
    prepareStep: prepareStep(agent, model, prompt, contextVariables),
  });
}

export const prepareStep = <C>(
  agent: Agent<any>,
  model: AgentModel,
  systemPrompt: string | undefined,
  contextVariables: C,
): PrepareStepFunction<NoInfer<Record<string, Tool>>> => {
  return async ({ steps, messages }) => {
    const step = steps.at(-1);
    const agentName = (contextVariables as any).currentActiveAgent;
    if (!step) {
      return await prepareAgent(
        systemPrompt,
        model,
        agent,
        messages,
        contextVariables,
      );
    }
    if (!agentName) {
      return await prepareAgent(
        systemPrompt,
        model,
        agent,
        messages,
        contextVariables,
      );
    }

    const nextAgent = findAgent(agent, agentName);
    if (!nextAgent) {
      console.error(`Debug: ${chalk.red('NotFound')}: Agent ${agentName}`);
      console.dir(
        {
          steps: steps.map(({ request, response, ...etc }) => etc),
          messages,
        },
        { depth: null },
      );
      return void 0;
    }
    return await prepareAgent(
      systemPrompt,
      model,
      nextAgent,
      messages,
      contextVariables,
    );
  };
};

export function swarm<C>(
  agent: Agent<C>,
  messages: UIMessage[] | string,
  contextVariables: C,
  systemPrompt?: string,
  abortSignal?: AbortSignal,
) {
  const originalMessages = Array.isArray(messages)
    ? messages
    : [messageToUiMessage(messages)];
  return createUIMessageStream({
    originalMessages,
    generateId: generateId,
    async execute({ writer }) {
      const stream = execute(
        agent,
        originalMessages,
        contextVariables,
        systemPrompt,
        { abortSignal },
      );
      const parts: UIMessagePart<UIDataTypes, UITools>[] = [];

      writer.merge(
        stream.toUIMessageStream({
          sendFinish: false,
          sendStart: true,
          onFinish: (event) => {
            parts.push(...event.responseMessage.parts);
          },
        }),
      );
      await stream.consumeStream({ onError: console.error });
      await last(stream.fullStream);

      if (!agent.prepareEnd) return;

      while (true) {
        const state = contextVariables as any;
        if (state.currentActiveAgent === undefined) {
          console.warn(
            `swarm: active agent was never set, so no prepareEnd call will be made`,
          );
          return;
        }
        if (state.currentActiveAgent === agent.internalName) {
          console.warn(
            `swarm: active agent is the root agent, so no prepareEnd call will be made`,
          );
          return;
        }
        const responseMessage = { id: '', parts, role: 'assistant' } as const;

        const stream = agent.prepareEnd({
          responseMessage,
          messages: [...originalMessages, responseMessage],
          contextVariables,
          abortSignal,
        });
        if (!stream) break;

        writer.merge(
          stream.toUIMessageStream({
            sendFinish: false,
            sendStart: false,
            onFinish: (event) => {
              parts.push(...event.responseMessage.parts);
            },
          }),
        );
        await stream.consumeStream({ onError: console.error });
        await last(stream.fullStream);
      }

      writer.write({ type: 'finish' });
    },
  });
}

export async function prepareAgent<C>(
  prompt: string | undefined,
  defaultModel: AgentModel,
  agent: Agent<C>,
  messages: ModelMessage[],
  contextVariables?: C,
): Promise<PrepareStepResult<NoInfer<Record<string, Tool>>>> {
  agent.debug();
  await agent.prepareHandoff?.(messages);

  let stepModel = agent.model ?? defaultModel;
  if (agent.output) {
    const json_schema = zodToJsonSchema(agent.output, {
      $refStrategy: 'root',
    });
    stepModel = wrapLanguageModel({
      model: stepModel,
      middleware: {
        transformParams: async ({ params }) => ({
          ...params,
          response_format: {
            type: 'json_schema',
            json_schema,
            name: `${agent.handoff.name}_output`,
          },
        }),
      },
    });
  }
  return {
    system: `${prompt || ''}\n${agent.instructions(contextVariables)}`,
    activeTools: agent.toolsNames,
    model: stepModel,
    messages,
    // messages: removeTransferCalls(messages),
    toolChoice: agent.toolChoice,
  } as const;
}

function getLastAgentFromSteps(
  steps: StepResult<NoInfer<Record<string, Tool>>>[],
): string | undefined {
  for (let i = steps.length - 1; i >= 0; i--) {
    const step = steps[i];
    for (const it of step.dynamicToolResults) {
      if (isTransferToolResult(it)) {
        return it.output.currentActiveAgent;
      }
    }
  }
  return void 0;
}

function findAgent<C>(agent: Agent<C>, agentName: string) {
  // FIXME: first argument agent not always the first passed agent.
  return [...agent.toHandoffs(), agent].find(
    (it) => it.handoff.name === agentName,
  );
}

function getActiveAgentName(messages: ModelMessage[]): string | undefined {
  for (let i = messages.length - 1; i >= 0; i--) {
    const message = messages[i];

    if (message.role === 'tool') {
      for (const block of message.content) {
        if (
          block.type === 'tool-result' &&
          block.toolName.startsWith('transfer_to_') &&
          block.output.type === 'json' &&
          isTransferToolResult({ output: block.output.value })
        ) {
          return (block.output.value as TransferTool['output'])
            .currentActiveAgent;
        }
      }
    }
  }
  return undefined;
}

function tagAgents(
  step: StepResult<NoInfer<Record<string, Tool>>>,
  defaultAgentName: string,
) {
  const { request, response, ...stepResult } = step;
  // let transferToolResultIdx = -1;
  const messages = response.messages;
  let agentName: string | undefined;

  // look for the last agent from the step
  for (let i = stepResult.content.length - 1; i >= 0; i--) {
    const block = stepResult.content[i];
    if (
      block.type === 'tool-result' &&
      block.dynamic &&
      block.toolName.startsWith('transfer_to_') &&
      isTransferToolResult(block)
    ) {
      // If we found a dynamic tool result, we can use it
      agentName = block.output.lastActiveAgent;
      // transferToolResultIdx = i;
      break;
    }
  }

  // if no agent in the step result, look for for it in the messages
  // todo: can we just use this instead of looking into the step result?
  if (!agentName) {
    for (const message of messages.slice(0).reverse()) {
      if (
        message.role === 'tool' &&
        message.content[0].type === 'tool-result' &&
        message.content[0].toolName.startsWith('transfer_to_') &&
        isTransferToolResult({
          output: message.content[0].output.value,
        })
      ) {
        agentName = (message.content[0].output.value as TransferTool['output'])
          .currentActiveAgent;
        break;
      }
    }
  }

  if (!agentName) {
    agentName = defaultAgentName;
  }

  for (const block of stepResult.content) {
    if (block.type === 'text' && !block.text.startsWith('<name>')) {
      block.text = `<name>${agentName}</name><content>${dedent(block.text)}</content>`;
    }
  }
  // console.log(
  //   `Debug: ${chalk.red('NoOp')}: No transfer tool result found.`,
  // );
  // console.dir({ stepResult, messages }, { depth: null });
}

function removeTransferCalls(messages: ModelMessage[]): ModelMessage[] {
  for (const message of messages) {
    if (message.role === 'assistant') {
      if (typeof message.content === 'string') continue;

      for (let i = message.content.length - 1; i >= 0; i--) {
        const block = message.content[i];
        if (typeof block === 'string') continue;

        if (
          (block.type === 'tool-call' || block.type === 'tool-result') &&
          block.toolName.startsWith('transfer_to_')
        ) {
          message.content.splice(i, 1);
        }
      }
    }
  }
  return messages;
}
